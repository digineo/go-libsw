package swlib

import (
	"testing"

	"github.com/mdlayher/genetlink"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"

	"github.com/mdlayher/netlink"
)

type connectorMock struct {
	mock.Mock
}

func (m connectorMock) Close() error {
	return nil
}

func (m connectorMock) Execute(msg genetlink.Message, family uint16, flags netlink.HeaderFlags) ([]genetlink.Message, error) {
	args := m.Called(msg, family, flags)
	return args.Get(0).([]genetlink.Message), args.Error(1)
}

func TestConn_ListSwitches(t *testing.T) {
	assert2 := assert.New(t)
	require2 := require.New(t)

	m := &connectorMock{}

	req := genetlink.Message{
		Header: genetlink.Header{
			Command: uint8(CmdGetSwitch),
			Version: 1,
		},
	}
	m.On("Execute", req, uint16(1), netlink.Request|netlink.Dump).Return(
		[]genetlink.Message{
			{
				Header: genetlink.Header{
					Command: 2,
					Version: 1,
				},
				Data: []byte{
					0x08, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x03, 0x00, 0x73, 0x77, 0x69, 0x74,
					0x63, 0x68, 0x30, 0x00, 0x0b, 0x00, 0x04, 0x00, 0x6d, 0x74, 0x37, 0x35, 0x33, 0x30, 0x00, 0x00,
					0x0b, 0x00, 0x05, 0x00, 0x6d, 0x74, 0x37, 0x35, 0x33, 0x30, 0x00, 0x00, 0x08, 0x00, 0x06, 0x00,
					0xff, 0x0f, 0x00, 0x00, 0x08, 0x00, 0x07, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x09, 0x00,
					0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x08, 0x00, 0x04, 0x00, 0x07, 0x00, 0x04, 0x00, 0x07, 0x00,
					0x04, 0x00, 0x07, 0x00, 0x04, 0x00, 0x07, 0x00, 0x04, 0x00, 0x07, 0x00, 0x04, 0x00, 0x07, 0x00,
					0x04, 0x00, 0x07, 0x00, 0x04, 0x00, 0x07, 0x00,
				},
			},
		},
		nil,
	)

	c := Conn{
		conn: m,
		family: genetlink.Family{
			ID:      1,
			Version: 1,
		},
	}

	switches, err := c.ListSwitches()
	require2.NoError(err)

	require2.Len(switches, 1)
	assert2.Equal(Device{
		ID:         1,
		DeviceName: "switch0",
		Alias:      "mt7530",
		Name:       "mt7530",
		VLANs:      4095,
		Ports:      8,
		CPUPort:    6,
		PortMap:    []*PortMap{{1, "", 0}, {2, "", 0}, {3, "", 0}, {4, "", 0}, {5, "", 0}, {6, "", 0}, {7, "", 0}, {8, "", 0}},
	}, switches[0])

	m.AssertExpectations(t)
}

func TestConn_ListGlobalAttributes(t *testing.T) {
	assert2 := assert.New(t)
	require2 := require.New(t)

	m := &connectorMock{}

	req := genetlink.Message{
		Header: genetlink.Header{
			Command: uint8(CmdListGlobal),
			Version: 1,
		},
		Data: []uint8{0x8, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0},
	}

	m.On("Execute", req, uint16(1), netlink.Request|netlink.Acknowledge).Return(
		[]genetlink.Message{
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x01, 0x00, 0x00, 0x00,
					0x10, 0x00, 0x0c, 0x00, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x76, 0x6c, 0x61, 0x6e, 0x00,
					0x1a, 0x00, 0x13, 0x00, 0x56, 0x4c, 0x41, 0x4e, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x20, 0x28, 0x31,
					0x3a, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x29, 0x00, 0x00, 0x00,
				},
			},
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x08, 0x00, 0x0a, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x02, 0x00, 0x00, 0x00,
					0x08, 0x00, 0x0c, 0x00, 0x6d, 0x69, 0x62, 0x00, 0x20, 0x00, 0x13, 0x00, 0x47, 0x65, 0x74, 0x20,
					0x4d, 0x49, 0x42, 0x20, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73, 0x20, 0x66, 0x6f, 0x72,
					0x20, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x00,
				},
			},
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x08, 0x00, 0x0a, 0x00, 0x00, 0x10, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x05, 0x00, 0x00, 0x00,
					0x0a, 0x00, 0x0c, 0x00, 0x61, 0x70, 0x70, 0x6c, 0x79, 0x00, 0x00, 0x00, 0x25, 0x00, 0x13, 0x00,
					0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73,
					0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65,
					0x00, 0x00, 0x00, 0x00,
				},
			},
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x08, 0x00, 0x0a, 0x00, 0x01, 0x10, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x05, 0x00, 0x00, 0x00,
					0x0a, 0x00, 0x0c, 0x00, 0x72, 0x65, 0x73, 0x65, 0x74, 0x00, 0x00, 0x00, 0x15, 0x00, 0x13, 0x00,
					0x52, 0x65, 0x73, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68,
					0x00, 0x00, 0x00, 0x00,
				},
			},
			{
				Header: genetlink.Header{Command: 0, Version: 0},
				Data: []byte{
					0x1c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x05, 0x00, 0xe5, 0x12, 0x66, 0x1e, 0x15, 0x2b, 0x00, 0x00,
				},
			},
		},
		nil,
	)

	c := Conn{
		conn: m,
		family: genetlink.Family{
			ID:      1,
			Version: 1,
		},
	}

	d := &Device{ID: 0}

	attributes, err := c.ListGlobalAttributes(d)
	require2.NoError(err)

	assert2.Len(attributes, 4)
	assert2.Equal(Attributes{
		"apply":       &Attribute{d, GroupGlobal, 4096, DataTypeNoVal, "apply", "Activate changes in the hardware"},
		"enable_vlan": &Attribute{d, GroupGlobal, 0, DataTypeInt, "enable_vlan", "VLAN mode (1:enabled)"},
		"mib":         &Attribute{d, GroupGlobal, 1, DataTypeString, "mib", "Get MIB counters for switch"},
		"reset":       &Attribute{d, GroupGlobal, 4097, DataTypeNoVal, "reset", "Reset the switch"},
	}, attributes)

	m.AssertExpectations(t)
}

func TestConn_ListPortAttributes(t *testing.T) {
	assert2 := assert.New(t)
	require2 := require.New(t)

	m := &connectorMock{}

	req := genetlink.Message{
		Header: genetlink.Header{
			Command: uint8(CmdListPort),
			Version: 1,
		},
		Data: []uint8{0x8, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0},
	}

	m.On("Execute", req, uint16(1), netlink.Request|netlink.Acknowledge).Return(
		[]genetlink.Message{
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x02, 0x00, 0x00, 0x00,
					0x08, 0x00, 0x0c, 0x00, 0x6d, 0x69, 0x62, 0x00, 0x1e, 0x00, 0x13, 0x00, 0x47, 0x65, 0x74, 0x20,
					0x4d, 0x49, 0x42, 0x20, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73, 0x20, 0x66, 0x6f, 0x72,
					0x20, 0x70, 0x6f, 0x72, 0x74, 0x00, 0x00, 0x00,
				},
			},
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x08, 0x00, 0x0a, 0x00, 0x00, 0x10, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x01, 0x00, 0x00, 0x00,
					0x09, 0x00, 0x0c, 0x00, 0x70, 0x76, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x13, 0x00,
					0x50, 0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x20, 0x56, 0x4c, 0x41, 0x4e, 0x20, 0x49, 0x44, 0x00,
				},
			},
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x08, 0x00, 0x0a, 0x00, 0x01, 0x10, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x04, 0x00, 0x00, 0x00,
					0x09, 0x00, 0x0c, 0x00, 0x6c, 0x69, 0x6e, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x13, 0x00,
					0x47, 0x65, 0x74, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x6c, 0x69, 0x6e, 0x6b, 0x20, 0x69, 0x6e,
					0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00,
				},
			},
			{
				Header: genetlink.Header{Command: 0, Version: 0},
				Data: []byte{
					0x1c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x05, 0x00, 0xe6, 0x12, 0x66, 0x1e, 0x15, 0x2b, 0x00, 0x00,
				},
			},
		},
		nil,
	)

	c := Conn{
		conn: m,
		family: genetlink.Family{
			ID:      1,
			Version: 1,
		},
	}

	d := &Device{ID: 0}

	attributes, err := c.ListPortAttributes(d)
	require2.NoError(err)

	assert2.Len(attributes, 3)
	assert2.Equal(Attributes{
		"mib":  &Attribute{d, GroupPort, 0, DataTypeString, "mib", "Get MIB counters for port"},
		"pvid": &Attribute{d, GroupPort, 4096, DataTypeInt, "pvid", "Primary VLAN ID"},
		"link": &Attribute{d, GroupPort, 4097, DataTypeLink, "link", "Get port link information"},
	}, attributes)

	m.AssertExpectations(t)
}

func TestConn_ListVLANAttributes(t *testing.T) {
	assert2 := assert.New(t)
	require2 := require.New(t)

	m := &connectorMock{}

	req := genetlink.Message{
		Header: genetlink.Header{
			Command: uint8(CmdListVLAN),
			Version: 1,
		},
		Data: []uint8{0x8, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0},
	}

	m.On("Execute", req, uint16(1), netlink.Request|netlink.Acknowledge).Return(
		[]genetlink.Message{
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x08, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x01, 0x00, 0x00, 0x00,
					0x08, 0x00, 0x0c, 0x00, 0x76, 0x69, 0x64, 0x00, 0x15, 0x00, 0x13, 0x00, 0x56, 0x4c, 0x41, 0x4e,
					0x20, 0x49, 0x44, 0x20, 0x28, 0x30, 0x2d, 0x34, 0x30, 0x39, 0x34, 0x29, 0x00, 0x00, 0x00, 0x00,
				},
			},
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x08, 0x00, 0x0a, 0x00, 0x00, 0x10, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x03, 0x00, 0x00, 0x00,
					0x0a, 0x00, 0x0c, 0x00, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x00, 0x00, 0x00, 0x16, 0x00, 0x13, 0x00,
					0x56, 0x4c, 0x41, 0x4e, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x6d, 0x61, 0x70, 0x70, 0x69, 0x6e,
					0x67, 0x00, 0x00, 0x00,
				},
			},
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x1c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x05, 0x00, 0xef, 0x12, 0x66, 0x1e, 0x15, 0x2b, 0x00, 0x00,
				},
			},
		},
		nil,
	)

	c := Conn{
		conn: m,
		family: genetlink.Family{
			ID:      1,
			Version: 1,
		},
	}

	d := &Device{ID: 0}

	attributes, err := c.ListVLANAttributes(d)
	require2.NoError(err)

	assert2.Len(attributes, 2)
	assert2.Equal(Attributes{
		"vid":   &Attribute{d, GroupVLAN, 0, DataTypeInt, "vid", "VLAN ID (0-4094)"},
		"ports": &Attribute{d, GroupVLAN, 4096, DataTypePorts, "ports", "VLAN port mapping"},
	}, attributes)

	m.AssertExpectations(t)
}

func TestConn_GetAttributeLink(t *testing.T) {
	assert2 := assert.New(t)
	require2 := require.New(t)

	m := &connectorMock{}

	req := genetlink.Message{
		Header: genetlink.Header{
			Command: uint8(CmdGetPort),
			Version: 1,
		},
		Data: []uint8{0x8, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0xa, 0x0, 0x1, 0x10, 0x0, 0x0, 0x8, 0x0, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0},
	}

	m.On("Execute", req, uint16(1), netlink.Request).Return(
		[]genetlink.Message{
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x14, 0x00, 0x12, 0x00, 0x04, 0x00, 0x01, 0x00, 0x04, 0x00, 0x02, 0x00, 0x08, 0x00, 0x06, 0x00,
					0xe8, 0x03, 0x00, 0x00,
				},
			},
		},
		nil,
	)

	c := Conn{
		conn: m,
		family: genetlink.Family{
			ID:      1,
			Version: 1,
		},
	}

	link, err := c.GetAttributeLink(&Attribute{&Device{ID: 0}, GroupPort, 4097, DataTypeLink, "link", "Get port link information"}, 0)
	require2.NoError(err)

	assert2.Equal(&Link{Link: true, Duplex: true, ANeg: false, TXFlow: false, RXFlow: false, Speed: 1000, EEE: 0}, link)

	m.AssertExpectations(t)
}

func TestConn_GetAttributePorts(t *testing.T) {
	assert2 := assert.New(t)
	require2 := require.New(t)

	m := &connectorMock{}

	req := genetlink.Message{
		Header: genetlink.Header{
			Command: uint8(CmdGetVLan),
			Version: 1,
		},
		Data: []uint8{0x8, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0xa, 0x0, 0x0, 0x10, 0x0, 0x0, 0x8, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0},
	}

	m.On("Execute", req, uint16(1), netlink.Request).Return(
		[]genetlink.Message{
			{
				Header: genetlink.Header{Command: 2, Version: 1},
				Data: []byte{
					0x44, 0x00, 0x11, 0x00, 0x0c, 0x00, 0x14, 0x00, 0x08, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
					0x0c, 0x00, 0x14, 0x00, 0x08, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x14, 0x00,
					0x08, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x14, 0x00, 0x08, 0x00, 0x01, 0x00,
					0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x14, 0x00, 0x08, 0x00, 0x01, 0x00, 0x06, 0x00, 0x00, 0x00,
					0x04, 0x00, 0x02, 0x00,
				},
			},
		},
		nil,
	)

	c := Conn{
		conn: m,
		family: genetlink.Family{
			ID:      1,
			Version: 1,
		},
	}
	link, err := c.GetAttributePorts(&Attribute{&Device{ID: 0}, GroupVLAN, 4096, DataTypePorts, "ports", "VLAN port mapping"}, 0)
	require2.NoError(err)

	assert2.Equal(Ports{{1, 0}, {2, 0}, {3, 0}, {4, 0}, {6, PortFlagTagged}}, link)

	m.AssertExpectations(t)
}

func TestConn_GetAttributeInt(t *testing.T) {
	assert2 := assert.New(t)
	require2 := require.New(t)

	m := &connectorMock{}

	req := genetlink.Message{
		Header: genetlink.Header{
			Command: uint8(CmdGetPort),
			Version: 1,
		},
		Data: []uint8{0x8, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0xa, 0x0, 0x0, 0x10, 0x0, 0x0, 0x8, 0x0, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0},
	}

	m.On("Execute", req, uint16(1), netlink.Request).Return(
		[]genetlink.Message{
			{
				Header: genetlink.Header{Command: 10, Version: 1},
				Data: []byte{
					0x08, 0x00, 0x0f, 0x00, 0x03, 0x00, 0x00, 0x00,
				},
			},
		},
		nil,
	)

	c := Conn{
		conn: m,
		family: genetlink.Family{
			ID:      1,
			Version: 1,
		},
	}
	value, err := c.GetAttributeInt(&Attribute{&Device{ID: 0}, GroupPort, 4096, DataTypeInt, "pvid", "Primary VLAN ID"}, 0)
	require2.NoError(err)

	assert2.Equal(uint32(3), value)

	m.AssertExpectations(t)
}
